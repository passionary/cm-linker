<!DOCTYPE html>
<html>
<head>
	<title>example</title>
	<meta charset="utf-8">
	<style>
		p{
			color: #000;
		}
	</style>
</head>
<body>	
	<h1>Hello</h1>
	<template id="temp">		
		<p>some</p>
	</template>
	<script>
		/* global variables */
		const helpers = {
			create(tag){
				return document.createElement(tag)
			},
			append(parent,node){
				return parent.appendChild(node)
			},
			remove(parent,child){
				parent.removeChild(child)
			},
			update(node,val){
				node.innerHTML = val
			},
			style(node){
				const styles = Array.from(arguments).slice(1)
				const rule = /([^:\s]{3,}):+\s?(\w+)/
				for(let i=0;i<styles.length;i++){			
					const s = styles[i].match(rule)[1]
					const v = styles[i].match(rule)[2]
					if(rule.test(styles[i])) node.style[s] = v			
				}
				return node
			}
		}		
		let html = document.createElement('div')		
		let dom = []
		let ranges
		let template = `
			<div>
				<span l-for="data in tests">
					{{data}}
				</span>			
			</div>							
			`		
		let object = {
			data: '1',
			tests:['hello','some','person!']
		}
		const proxy = new Proxy(object, {
    	get(target, prop){
    		return target[prop]
    	},
    	set(target, prop, val, receiver) {
    		target[prop] = val    		
    		html = main()
    		return true
    	}	
		})		
		function defineNodes(temp)
		{
			let rules = {
				tag: '(?<=[\\s]*)(?<=\<)[\\w]+',
				cTag: '(?<=\/)[\\w]+',
				inner: '(?<=\{\{\)[\\w]+(?=\}\})',
				lfor: '(?<=for=")[^"]+(?=")',
				innerText: '[^\{\}]+'
			}

			let nexts = Array.from(temp.matchAll(/\n/g)).map(i => i.index + 1)
			let pointer = 0
			let current = 0

			function next(){			
				current = nexts[pointer++]
			}
			let sopens = Array.from(temp.matchAll(new RegExp(rules.tag,'g')))			
			let scloses = Array.from(temp.matchAll(new RegExp(rules.cTag,'g')))
			if(sopens.length != scloses.length) throw Error('invalid html in template')
			let nodes = []
			let crtag = ''
			function back(){
				current = nexts[pointer - 2]
				pointer--
			}
			let inner
			while(current < temp.length && nodes.length != sopens.length){
				let str = temp.slice(current,nexts[pointer])
				let tag = str.match(new RegExp(rules.tag))				
				let cTag = str.match(rules.cTag)
				if(tag && tag[0] && !nodes.find(i => i.tag[0] == pointer)){
					crtag = {id:pointer,tag}
					next()
					continue
				}else	if(cTag && crtag && crtag.tag && cTag[0] && crtag.tag[0] && crtag.tag[0] == cTag[0] && !nodes.find(i => i.etag[0] == pointer)){
					const expr = temp.slice(nexts[crtag.id-1],nexts[crtag.id]).match(new RegExp(rules.lfor)) || ['']
					const forExp = expr[0]
					const [key,data] = [forExp.split(' ')[0],forExp.split(' ')[2]]
					let obj = {
						tag:[crtag.id,crtag.tag],
						etag:[pointer,cTag],						
					}
					console.log(key,data)
					if(inner = temp.slice(nexts[pointer-2],nexts[pointer-1]).match(new RegExp(rules.inner))) {
						obj.inner = inner
					}
					if(data) obj.fdata = [data,object[data].length]
					nodes.unshift(obj)
					crtag = 'no'
					next()
					continue
				}else if(crtag === 'no'){
					back()
					continue
				}
				next()
			}
			return nodes
		}			
		function render(array)
		{
			let html = helpers.create('div')
			let i = 0
			let buf
			let down = false			
			while(i < array.length){
				let e = array[i]
				let en = array[i+1]
				if(!en)	break
				if(array.length == 1) {
					e[0].node = helpers.create(e[0].tag[1][0])
					if(e[0].inner) {
						e[0].node.innerHTML = e[0].inner[0]
					}
					break
				}

				if(down && buf) {
					if(array[buf][1] - e[1] == 1) {
						e[0].node.appendChild(array[buf][0].node)
						i = buf
						down = false						
						continue
					}

					i--
					continue
				}

				if(en[1] - e[1] == 1){
					e[0].node = e[0].node || helpers.create(e[0].tag[1][0])
					en[0].node = en[0].node || helpers.create(en[0].tag[1][0])
					if(en[0].inner) {
						en[0].node.innerHTML = object[en[0].inner[0]]
					}
					if(en[0].fdata) {					
						for(let i=0;i<en[0].fdata[1];i++) {
							let el = en[0].node.cloneNode(true)
							el.innerHTML = object[en[0].fdata[0]][i]
							e[0].node.appendChild(el)
						}						
					}else{
						e[0].node.appendChild(en[0].node)
					}					
					i++
					continue
				}

				if(en[1] - e[1] < 1 && en[1] != 0){
					en[0].node = helpers.create(en[0].tag[1][0])
					buf = i + 1
					down = true
					continue
				}else if(en[1] == 0 && i > 0){
					en[0].node = helpers.create(en[0].tag[1][0])
				}

				i++
			}
			array.filter(e => e[1] == 0).forEach(i => html.appendChild(i[0].node))			
			return html
		}
		function makeOutput(array)
		{			
			ranges = array.sort((a,b) => a.tag[0] - b.tag[0])
			recursion(ranges)			
			return defineDom(ranges,dom)
		}
		/* -----Array-----

				[1, 18, 17]   STEPS: 1) nearest: [1, 18, 17] - at the beginning
				[14, 17, 3]					 2) nearest - [2, 6, 4] - at the beginning of max
				[15, 16, 1]					 3) next - [3, 5, 2] - is into nearest
				[7, 13, 6]					 4) next - [7, 13, 6] - out of nearest and after him
				[10, 12, 2]					 5) nearest - [8, 9, 1] - into [7, 13, 6]
				[8, 9, 1]						 6) next - [10, 12, 2] - into [7, 13, 6] after [8, 9, 1]
				[2, 6, 4]						 7) next - [14, 17, 3] - after [7, 13, 6]
				[3, 5, 2]						 8) nearest - [15, 16, 1] - into [14, 17, 3]

			 -----Array-----
		*/	
		function recursion(rangs){			
			for(let i=0;i<rangs.length;i++){
				const id = ranges.findIndex(e => e == rangs[i])			
				const children = ranges.filter(e => e.tag[0] > rangs[i].tag[0] && e.etag[0] < rangs[i].etag[0])
				if(children.length){
					dom[id] = children.map(e => ranges.findIndex(el => el == e)).join(',')
					recursion(children)
				}else	dom[id] = ''				
			}			
		}
		function defineDom(ranges,array){
			let DOM = []
			for(let i=0;i<array.length;i++){				
				const count = array.filter(e => new RegExp(`\\b${i}\\b`).test(e)).length
				DOM.push([ranges.find((e,index) => index == i),count])
			}			
			return DOM
		}
		function main()
		{
			return render(makeOutput(defineNodes(template)))
		}		
	</script>
<script type="text/javascript" src="../dist/bundle.js"></script>
</body>
</html>